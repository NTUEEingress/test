
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - trackball controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;

			}

			a {
				color: red;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>
		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - trackball controls example</br>
			MOVE mouse &amp; press LEFT/A: rotate, MIDDLE/S: zoom, RIGHT/D: pan
			</br>Score : <font id="score"></font><button onclick="reinit()">Restart</button>
		</div>			
		<script src="../build/three.min.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/TrackballControls.js"></script>
		<script src="js/renderers/Projector.js"></script>
		<script src="js/Detector.js"></script>
		<script src="fonts/helvetiker_bold.typeface.js"></script>

		<script>

			if ( !Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, controls, scene, renderer, raycaster,raycaster_move_heli;
			var num = 5;
			var nodeList = [];
			var mouse_click = new THREE.Vector2(),INTERSECTED_M,INTERSECTED_C;
			var mouse_move = new THREE.Vector2();
			var x = [], y = [];
			var helicopter = [] , velocity = [] , destination = [] , move_or_not = [ false , false ] ;
			var closeToPortal = [ false , false ] , portalId = [] ;
			var timeOrigin = [] ;
			var controlled = [] ;
			var portalColor = [] ;
			var PortalEffect = [];//0: none,1: speed buff,
			var CountStart = 0 , NUM = "6" , NUMP = "6" , PID = 5 , Source = 0 ;
			var MAP = new Map() ; MAP.set( "6" , 1 ) ;
			//for score
			var SCORES=0;
			var tower=[0,0];
			var score=[0,0];
			// outline
			var outlineOffset = 5 ;


			init();
			animate();

			function init() { //{{{
				// camera
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );
				camera.position.set(0,-400,800);

				controls = new THREE.TrackballControls( camera );

				controls.rotateSpeed = 1.2;
				controls.zoomSpeed = 1.0;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];

				controls.addEventListener( 'change', render );

				// world

				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0xcccccc, 0 );
				//Circles
				var geometry_circle = new THREE.CircleGeometry(40,32);

				for ( var i = 0 ; i < num ; i ++ ) {
					var mesh_circle = new THREE.Mesh(geometry_circle,new THREE.MeshBasicMaterial( { color: 0xffffff} ));
					do {
						x[i] = Math.random() * 480 - 240;
						y[i] = Math.random() * 480 - 240;
						var flag = 0 ;
						for ( var j = 0 ; j < i ; j ++ ) {
							if ( ( Math.pow( x[ i ] - x[ j ] , 2 ) + Math.pow( y[ i ] - y[ j ] , 2 ) ) < Math.pow( 200 , 2 ) )
								flag = 1 ;
						}
						if ( flag == 0 ) { break ; }
					} while ( true ) ;
					mesh_circle.position.x = x[i];
					mesh_circle.position.y = y[i];
					controlled[ i ] = 100;
					portalColor[ i ] = 0 ;
					scene.add( mesh_circle ) ;
					nodeList.push( mesh_circle ) ;
				}

					
				//outline
				for ( var i = 0 ; i < num ; i ++ ) {
					var outline_geometry = new THREE.RingGeometry( 40, 50, 32 , 8 , 0 , 0 ) ;
					var outlineMaterial1 = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } ) ;
					var outlineMesh1 = new THREE.Mesh( outline_geometry, outlineMaterial1 ) ;
					outlineMesh1.position.x = x[ i ] ;
					outlineMesh1.position.y = y[ i ] ;
					scene.add( outlineMesh1 );
				}

				SetPortalEffect();
				raycaster = new THREE.Raycaster();

				// helicopter
				for ( var i = 0 ; i < 2 ; i ++ ) {
					var geometry_helicopter = new THREE.SphereGeometry( 35 , 20 , 20 ) ;
					var material_helicopter ;
					if ( i == 1 ) material_helicopter = new THREE.MeshLambertMaterial( { color: 0x00ff00 } ) ;
					else material_helicopter = new THREE.MeshLambertMaterial( { color: 0xff0000 } ) ;
					helicopter[ i ] = new THREE.Mesh( geometry_helicopter , material_helicopter ) ;
					velocity[ i ] = 5 ;
					helicopter[ i ].position.x = x[ 0 ] ;
					helicopter[ i ].position.y = y[ 0 ] ;
					helicopter[ i ].position.z = 35 * ( i * 2 - 1 ) ;
					scene.add( helicopter[ i ] ) ;
				}

				destination[ 0 ] = new THREE.Vector2(x[0], y[0]);
				destination[ 1 ] = new THREE.Vector2(x[0], y[0]);

				// Misc
				//mouse
				document.addEventListener('mousedown',onDocumentMouseDown,false);
				document.addEventListener('mousemove',onDocumentMouseMove,false);
				projector = new THREE.Projector();

				// lights
				light = new THREE.AmbientLight( 0xaaaaaa );
				scene.add( light );
				//Grid Plane
				var size = 400,step = 50;
				var geometry_plane = new THREE.Geometry();
				var material_plane = new THREE.LineBasicMaterial({color:'white'});

				for(var i = -size;i<=size;i+=step){
					geometry_plane.vertices.push( new THREE.Vector3( -size,i,-1 ) );
					geometry_plane.vertices.push( new THREE.Vector3( size,i,-1) );

					geometry_plane.vertices.push( new THREE.Vector3(i,-size,-1));
					geometry_plane.vertices.push( new THREE.Vector3(i,size,-1) );
				}
				var line = new THREE.Line( geometry_plane,material_plane,THREE.LinePieces );
				scene.add(line);

				// renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				render();

				console.log("initialized");
			} //}}}
			function reinit(){
				
				camera.position.set(0,-400,800);
				for(var i=0;i<2;i++){
					helicopter[i].position.x = x[0];
					helicopter[i].position.y = y[0];
					destination[i].x = x[0];
					destination[i].y = y[0];
					velocity[i] = 5;
				}
				score = [0,0];
				for(var i=0;i<num;i++){
					portalColor[i] = 0;
					controlled[i] = 100;
				}
				for ( var i = 0 ; i < num ; i ++ ) {
						scene.children[ outlineOffset + i].geometry = new THREE.RingGeometry( 40, 50, 32 , 8 , 0 , portalColor[ i ] / 300 * Math.PI * 2 ) ;
				}
				console.log("reinit called")
			}	
			
			/* {{{
			//use this funtion to print Score

			function PrintScore(){
				SCORES++;
				document.getElementById("score").innerHTML = SCORES;
			}
			function CountDown(){ //{{{
				if(!MAP.has(NUM)){
					var textGeo = new THREE.TextGeometry( NUM , {
						size: 50,
						height: 12.5,
						curveSegments: 20,
						font: "helvetiker",
						weight: "bold",
						style: "normal",
						bevelThickness: 1.5,
						bevelSize: 1,
						bevelEnabled: true
					});
					textGeo.computeBoundingBox();
					var textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000  , specular: 0xffffff } );
					var mesh = new THREE.Mesh( textGeo, textMaterial );
					mesh.position.x = scene.children[PID].position.x-25;
					mesh.position.y = scene.children[PID].position.y-25;
					mesh.position.z = 100;
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					mesh.rotation.x = 90 ;
					mesh.rotation.y = 0 ;
					mesh.rotation.z = 0 ;
					if(Source>0){scene.remove(scene.children[scene.children.length-1]);MAP.delete(NUMP);Source--;}
					scene.add( mesh );
					Source++;
					MAP.set(NUM,1);
					NUMP=NUM;
				}
			} //}}}

			function Count(){
				if(CountStart==1){
					var tmp = Date.now() - timeOrigin ;
					if(tmp < 5000) NUM = ( 5 - Math.floor( tmp / 1000 ) ).toString() ;
					else {
						NUM="6";
						CountStart=0;
						scene.remove(scene.children[scene.children.length-1]);
						MAP.delete(NUMP);
						Source--;NUMP="6";
					}
					CountDown();
				}
			}
			}}} */
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.handleResize();

				render();
			}
			function onDocumentMouseMove( event ) {
				event.preventDefault();

				mouse_move.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse_move.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}
			function onDocumentMouseDown( event ) {
				event.preventDefault() ;

				var button = event.button ;
				console.log("Click.");
				// console.log(velocity[0],velocity[1]);

				mouse_click.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse_click.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				//move helicopter
				raycaster.setFromCamera(mouse_click,camera) ;
				var intersect_click = raycaster.intersectObjects(nodeList) ;

				if ( intersect_click.length > 0 ) {
					//helicopter move or not
					if ( button == 0 ) {
						destination[ 0 ].x = intersect_click[0].object.position.x;
						destination[ 0 ].y = intersect_click[0].object.position.y;
						move_or_not[ 0 ] = true ;
					} else if ( button == 2 ) {
						destination[ 1 ].x = intersect_click[0].object.position.x;
						destination[ 1 ].y = intersect_click[0].object.position.y;
						move_or_not[ 1 ] = true ;
					}
				}
			}
			function animate() {
				changeColor();
				//Count();
				updatescore();
				BuffDetector();
				controls.update();
				//render_move();
				render_click();
				requestAnimationFrame( animate );
			}
			function changeColor(){
				for ( var i = 0 ; i < num ; i ++ ) {
					var nearPortal = [false, false];
					for ( var j = 0 ; j < 2 ; j ++ ) {
						if ( Math.hypot( helicopter[ j ].position.x - x[i] , helicopter[ j ].position.y - y[i] ) < 20) {
							if ( j == 0 && portalColor[ i ] < 300 ) portalColor[ i ] ++ ;
							else if ( j == 1 && portalColor[ i ] > -300 ) portalColor[ i ] -- ;
							nearPortal[j] = true;
						}
						else {
							if ( j == 0 && portalColor[ i ] > 0 && portalColor[ i ] != 300) portalColor[ i ] -- ;
							else if ( j == 1 && portalColor[ i ] < 0 && portalColor[ i ] != -300) portalColor[ i ] ++ ;
						}
					}
					
					if ( controlled[i] == 1 && portalColor[ i ] != 300 && !( !nearPortal[0] && nearPortal[1] ))	portalColor[ i ] ++ ;
					else if ( controlled[i] == 0 && portalColor[ i ] != -300 && !( !nearPortal[1] && nearPortal[0] ))	portalColor[ i ] -- ;
					
					if ( portalColor[ i ] == 0 ){
						scene.children[ i ].material.color.setHex( 0xffffff ) ;
						controlled[i] = 100;
					}
					else if ( portalColor[ i ] > 0 ) {
						scene.children[ i ].material.color.setHex( 0xffffff - 0x000101 * Math.floor( portalColor[ i ] / 300 * 255 ) ) ;
						scene.children[ outlineOffset + i].geometry = new THREE.RingGeometry( 40, 50, 32 , 8 , 0 , portalColor[ i ] / 300 * Math.PI * 2 ) ;
						if ( portalColor[ i ] == 300 )	controlled[i] = 1;
					} else if ( portalColor[ i ] < 0 ) {
						scene.children[ i ].material.color.setHex( 0xffffff - 0x010001 * Math.floor( -portalColor[ i ] / 300 * 255 ) ) ;
						scene.children[ outlineOffset + i].geometry = new THREE.RingGeometry( 40, 50, 32 , 8 , 0 , portalColor[ i ] / 300 * Math.PI * 2 ) ;
						if ( portalColor[ i ] == -300 )	controlled[i] = 0;
					}
				}
				/*
				for ( var j = 0 ; j < 2 ; j ++ ) {
					if ( !closeToPortal[ j ] ) {
						for ( var i = 0 ; i < num ; i ++ ) {
							if ( !controlled[ i ] && Math.hypot( helicopter[ j ].position.x - x[i] , helicopter[ j ].position.y - y[i] ) < 20) {
								closeToPortal[ j ] = true , portalId[ j ] = i ;
								timeOrigin[ j ] = Date.now() ;
								CountStart = 1 ;
								PID = i ;
								break ;
							}
						}
					} else {
						if ( Math.hypot( helicopter[ j ].position.x - x[ portalId[ j ] ] , helicopter[ j ].position.y - y[ portalId[ j ] ] ) >= 20 ) {
							scene.children[ portalId[ j ] ].material.color.setHex( 0xffffff ) ;
							closeToPortal[ j ] = false ;
						} else {
							var tmp = Date.now() - timeOrigin[ j ] ;
							if ( tmp >= 5000 ) {
								closeToPortal[ j ] = false ;
								controlled[ portalId[ j ] ] = true ;
							} else {
								var color = 0xffffff - ( 255 * tmp / 5000 ) ;
								scene.children[ portalId[ j ] ].material.color.setHex( color ) ;
							}
						}
					}
				}
				*/
			}
			//portalEffect manager
			function SetPortalEffect(){
				//Speed Buff
				PortalEffect[0] = 1;
				//
			}
			//Buff detector
			function BuffDetector(){
				for(var i=0;i<num;i++){
					if((portalColor[i] == 300 )&& (PortalEffect[i] == 1)){
						velocity[0] = 10;
					}
					if((portalColor[i] == -300) && (PortalEffect[i] ==1)){
						velocity[1] = 10;
					}
				}
				// console.log(portalColor[0],PortalEffect[0],velocity[0],velocity[1]);
			}
			function render_move(){
				//find intersection_move
				raycaster.setFromCamera(mouse_move,camera);
				var intersect_move = raycaster.intersectObjects(scene.children)

				if ( intersect_move.length > 0 ) {
					if ( INTERSECTED_M ) INTERSECTED_M.material.color.setHex( INTERSECTED_M.currentHex );
					console.log("10231654520");
					INTERSECTED_M = intersect_move[ 0 ].object;
					INTERSECTED_M.currentHex = INTERSECTED_M.material.color.getHex();
					INTERSECTED_M.material.color.setHex( 0x00ff00 );
				}

				renderer.render(scene,camera);
			}
			function render_click(){
				//move helicopter
				for ( var i = 0 ; i < 2 ; i ++ ) {
					if( Math.hypot( destination[ i ].x - helicopter[ i ].position.x , destination[ i ].y - helicopter[ i ].position.y )
					   <= velocity[ i ] ) {
						move_or_not[ i ] = false;
					} else if ( move_or_not[ i ] == true ) {
						var distance = Math.hypot( destination[ i ].x - helicopter[ i ].position.x , destination[ i ].y - helicopter[ i ].position.y ) ;
						helicopter[ i ].position.x += velocity[ i ] * ( destination[ i ].x - helicopter[ i ].position.x ) / distance ;
						helicopter[ i ].position.y += velocity[ i ] * ( destination[ i ].y - helicopter[ i ].position.y ) / distance ;
						//console.log( destination[ i ].x , destination[ i ].y ) ;
						//console.log(helicopter.position.x,helicopter.position.y);
					}
				}

				renderer.render( scene , camera ) ;
			}
			function render(){
				renderer.render( scene , camera ) ;
				stats.update();
			}
			
			function updatetower(){

				
			}
			
			function updatescore(){
				/*for(var i=0;i!=2;i++)
				{
					score[i]+=tower[i]*100;
					
				}*/
				for(var i=0;i<num;i++)
				{
					if(portalColor[i]==300)
						score[0]++;
					else if(portalColor[i]==-300)
						score[1]++;
				}
				document.getElementById("score").innerHTML = score[0]+":"+score[1];
			}

		</script>

	</body>
</html>

